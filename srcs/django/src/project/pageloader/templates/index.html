<!DOCTYPE html>
<html lang="en">
<head>
    {% load static %}
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Pong</title>
    <!-- Includi il CSS di Bootstrap -->
    <link rel="stylesheet" href="/static/css/bootstrap.min.css">
    <link rel="stylesheet" href="/static/css/bootstrap.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/style.css">
    <!-- Includi jQuery, Popper.js, e il JavaScript di Bootstrap -->
    <script src="/static/js/lib/jquery.min.js"></script>
    <script src="/static/js/lib/popper.min.js"></script>
    <script src="/static/js/lib/bootstrap.min.js"></script>
    <script src="/static/js/lib/jquery.min.js"></script>
    <script src="/static/js/lib/popper.min.js"></script>
    <script src="/static/js/lib/bootstrap.min.js"></script>
    
    <!-- Includi Three.js -->
    <script src="/static/js/game/module/three.min.js"></script>    

    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        #app {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
    </style>    
</head>
<body id="body">
    <div id="app">
    </div>
    <script>
        async function recoverUser(id) {
            let accessToken = localStorage.getItem("accessToken");
            const checkAndRefreshToken = async () => {
                try {
                    const response = await fetch(`/api/token/refresh/?token=${accessToken}`, {
                        method: 'GET',
                    });

                    const data = await response.json();

                    if (data.message === 'Token valido') {
                        return accessToken;
                    } else if (data.message === 'Token non valido') {
                        // Il token non è valido, tentiamo di rinnovarlo
                        const newAccessToken = await refreshAccessToken();
                        if (newAccessToken) {
                            localStorage.setItem('accessToken', newAccessToken);
                            return newAccessToken;
                        } else {
                            console.error('Impossibile rinnovare il token');
                            return null;
                        }
                    } else {
                        console.error('Errore durante il controllo del token:', data.error);
                        return null;
                    }
                } catch (error) {
                    console.error('Errore durante la verifica o il rinnovo del token:', error);
                    return null;
                }
            };

            accessToken = await checkAndRefreshToken();
            if (!accessToken) {
                return;
            }
            try {
                const response = await fetch(`/api/request_user/${id}/`, {
                    method: "GET",
                    headers: {
                        "Authorization": `Bearer ${accessToken}`
                    }
                });

                const text = await response.text();  

                if (!response.ok) {
                    console.error(`Errore nella risposta della rete: ${response.status} ${response.statusText}`);
                    throw new Error('Network response was not ok');
                }

                const data = JSON.parse(text);  // Prova a fare il parse del messaggio

                return data; // Modifica questo percorso in base alla struttura della tua risposta

            } catch (error) {
                console.error('Errore durante il recupero dei dati dell\'utente:', error);
                throw error;
            }
        }
        async function recoverUser(id) {
            let accessToken = localStorage.getItem("accessToken");
            const checkAndRefreshToken = async () => {
                try {
                    const response = await fetch(`/api/token/refresh/?token=${accessToken}`, {
                        method: 'GET',
                    });

                    const data = await response.json();

                    if (data.message === 'Token valido') {
                        return accessToken;
                    } else if (data.message === 'Token non valido') {
                        // Il token non è valido, tentiamo di rinnovarlo
                        const newAccessToken = await refreshAccessToken();
                        if (newAccessToken) {
                            localStorage.setItem('accessToken', newAccessToken);
                            return newAccessToken;
                        } else {
                            console.error('Impossibile rinnovare il token');
                            return null;
                        }
                    } else {
                        console.error('Errore durante il controllo del token:', data.error);
                        return null;
                    }
                } catch (error) {
                    console.error('Errore durante la verifica o il rinnovo del token:', error);
                    return null;
                }
            };

            accessToken = await checkAndRefreshToken();
            if (!accessToken) {
                return;
            }
            try {
                const response = await fetch(`/api/request_user/${id}/`, {
                    method: "GET",
                    headers: {
                        "Authorization": `Bearer ${accessToken}`
                    }
                });

                const text = await response.text();  

                if (!response.ok) {
                    console.error(`Errore nella risposta della rete: ${response.status} ${response.statusText}`);
                    throw new Error('Network response was not ok');
                }

                const data = JSON.parse(text);  // Prova a fare il parse del messaggio

                return data; // Modifica questo percorso in base alla struttura della tua risposta

            } catch (error) {
                console.error('Errore durante il recupero dei dati dell\'utente:', error);
                throw error;
            }
        }
        const url = window.location.href;
        if (url.includes("game") || url.includes("lobby")) {
            console.log("URL contiene 'game' o 'lobby'. Esecuzione comportamento specifico...");
            if ((url.includes("local") || url.includes("single")) && !url.includes("create")) {
                localStorage.setItem("redirect", "tolocal");
            } else {
                let storage = window.localStorage;
                console.log("lo storage", storage);
                console.log("URL contiene 'online'. Esecuzione comportamento specifico...");
                if (url.includes("lobby")) {
                    console.log("URL contiene 'lobby'. Esecuzione comportamento specifico...");
                    let sanitizedUrl = url.endsWith("/") ? url.slice(0, -1) : url;
    
                    let lobbyId = sanitizedUrl.split("/").pop();
                    
                    console.log("Lobby ID:", lobbyId);
                    recoverUser(localStorage.getItem("userId")).then((data) => {
                        console.log("Dati utente recuperati:", data);
                        if (data) {
                            let lobby = data.in_game_lobby;
                            console.log("lobby", lobby, lobbyId);
                            if (lobby == lobbyId) {
                                console.log("Lobby trovata");
                            } else {
                                console.log("Lobby non trovata");
                                localStorage.setItem("redirect", "lobby");
                            }
                        }
                    });
                }  else {
                    console.log("URL NON contiene 'lobby'. Esecuzione comportamento specifico...");
                    let gameId = url.split("/").pop();
                    let userId = localStorage.getItem("userId");
                    console.log("Game ID:", userId, gameId);
                    recoverUser(userId).then((data) => {
                        console.log("Dati utente recuperati:", data);
                        if (data) {
                            let sanitizedUrl = url.endsWith("/") ? url.slice(0, -1) : url;
                            let gameId = sanitizedUrl.split("/").pop();
                            console.log("Utente autorizzato a visualizzare la pagina");
                            let game = data.game_history;
                            console.log("game", game);
                            game.forEach(element => {
                                if(element.id == gameId) {
                                    console.log("Elemento trovato", element);
                                    if(element.status != "finished" && element.status != "not_started") {
                                        console.log("Partita attiva");
                                    } else {
                                        console.log("Partita non attiva");
                                        localStorage.setItem("redirect", "game");
                                    }
                                }
                            });
                        }
                    });
                }              
            }
            //localStorage.setItem("redirect", "game");
        }
        window.initStarSky = function () {
            window.starScene = new THREE.Scene();
            window.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            window.renderer = new THREE.WebGLRenderer();
    
            const particlesGeometry = new THREE.BufferGeometry();
            const counts = 3000;
            const positionsStars = new Float32Array(counts * 3);
            const range = 420;
    
            for (let i = 0; i < counts * 3; i++) {
                positionsStars[i] = (Math.random() * range) - (range / 2);
            }
    
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positionsStars, 3));
            const particlesMaterial = new THREE.PointsMaterial();
            particlesMaterial.size = 0.2;
            particlesMaterial.sizeAttenuation = true;
    
            window.particles = new THREE.Points(particlesGeometry, particlesMaterial);
            window.renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(window.renderer.domElement);
    
            // Crea le particelle del cielo stellato
            window.particles.position.set(0, 100, -100);
            window.starScene.add(particles);
    
            // Aggiungi luce alla scena
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            window.starScene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(10, 10, 10);
            window.starScene.add(pointLight);
    
            // Imposta la posizione della camera
            //camera.position.z = 100;
            window.camera.position.set(0, -40, 25);
            window.camera.rotation.set(0.75, 0, 0);
        }

        // Funzione di animazione
        window.animateStarSky = function ( ) {
            requestAnimationFrame(animateStarSky);
            window.particles.rotation.x = 0.75;
            window.particles.rotation.y += 0.001; // Aggiunge una rotazione lenta alle stelle
            window.renderer.render(starScene, camera);
        }
        window.singleSkyScene = function () {
            window.particles.rotation.x = 0.75;
            window.particles.rotation.y += 0.001; // Aggiunge una rotazione lenta alle stelle
            window.renderer.render(starScene, camera);
        }
        window.initStarSky(window.renderer, window.starScene, window.camera, window.particles, window.starScene);
        window.animateStarSky( window.renderer, window.starScene, window.camera, window.particles);

        window.clearScene = function (scene) {
            if(scene != null) {
                while (scene.children.length > 0) {
                    const object = scene.children[0];
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) object.material.dispose();
                    scene.remove(object);
                }
            }
        }

        window.clearAllScene = function () {
            window.clearScene(window.starScene);
            window.clearScene(window.gameScene);
            window.starScene = null;
            window.gameScene = null;
        }

        // Gestisci la ridimensionamento della finestra
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
        {% load static %}
    <script src="{% static '/js/main.js' %}"></script>    
</body>
</html>
